.. _akustika_socivo:

Дводимензиони проблем са сочивом
======================================

Овај одељак се бави нешто модификованим `примером из туторијала <https://www.dealii.org/current/doxygen/deal.II/step_29.html>`_ за познати софтверски оквир за рад са методом коначних елемената **Deal.II**. Првобитна сврха овог примера је да симулира својства фокусирања ултразвучног таласа који генерише сочиво претварача са променљивом геометријом. Савремене примене у медицинском имиџингу користе ултразвучне таласе не само за сврхе снимања, већ и за изазивање одређених локалних ефеката у материјалу, као што су промене у оптичким својствима, које се затим могу мерити другим техникама снимања. Витални састојак ових метода је способност фокусирања интензитета ултразвучног таласа у одређеном делу материјала, идеално у тачки, како би се могла испитати својства материјала на тој локацији.

Карактеристична таласна дужина ултразвука нешто мања од феномена које смо до сада моделовали ФПНМ методом, те би нам био потребан изузетно велики број колокационих тачака што продужава тренирање. Зато смо таласну дужину нешто повећали (смањили фреквенцију), док остале параметре нисмо мењали. 

Како бисмо извели једначине за овај проблем, звук узимамо као талас којим се шири промена притиска: 

.. math::
    \frac{\partial^2 U}{\partial t^2} - c^2 \Delta U = 0, 

где је :math:`c` брзина звука, која се због једноставности узима као константа, :math:`U = U(x,t) ,\; x \in \Omega, \; t \in \mathrm{R}`. Поставка проблема дата је на :numref:`akustika-socivo`.

.. _akustika-socivo:

.. figure:: akustika3.png
    :width: 60%

    Поставка проблема и гранични услови

Граница :math:`\Gamma=\partial\Omega` подељена је на два дела, и то :math:`\Gamma_1` и :math:`\Gamma_2 = \Gamma\setminus\Gamma_1`, где :math:`\Gamma_1` представља сочиво, а :math:`\Gamma_2` апсорбујућу границу. Заправо, желимо да направимо такав гранични услов на :math:`\Gamma_2` тако да се опонаша знатно већи домен. На :math:`\Gamma_1`, претварач генерише таласе константне фреквенције :math:`\omega > 0` и константне јединичне амплитуде:

.. math::
    U(x,t) = \cos{\omega t}, \qquad x\in \Gamma_1

Пошто нема других (интерних или граничних) извора и пошто само извор емитује таласе фреквенције :math:`\omega`, дозвољено је да извршимо раздвајање променљивих :math:`U(x,t) = \textrm{Re}\left(u(x)\,e^{i\omega t})\right)`. Комплексна функција :math:`u(x)` описује просторну зависност амплитуде и фазе (релативно у односу на извор) таласа фреквенције :math:`\omega`, док је амлитуда величина која нас интересује. Ако овако формулисану функцију уврстимо у таласну једначину, видимо да за :math:`u` имамо

.. math::
    -\omega^2 u(x) - c^2\Delta u(x) = 0, \qquad x \in \Omega, \\
    u(x) = 1,  \qquad x \in \Gamma_1.

Да бисмо нашли одговарајуће граничне услове на :math:`\Gamma_2` који опонашају апсорбујућу границу, размотримо талас облика :math:`V(x,t)=e^{i(k\cdot x - \omega t)}` фреквенције :math:`\omega` који се простире у правцу :math:`k \in {\mathrm{R}^2}`. Да би :math:`V` био решење таласне једначине, мора да важи :math:`|k|=\frac{\omega}{c}`. Претпоставимо да талас долази до :math:`x_0 \in \Gamma_2` под правим углом, на пример :math:`n=\frac{k}{|k|}` где :math:`n` означава нормалу на :math:`\Omega \in x_0`. Онда у :math:`x_0`, овај талас задовољава једначину

.. math::
    c (n\cdot\nabla V) + \frac{\partial V}{\partial t} = (i\, c\, |k| - i\, \omega) V = 0.

Постављањем граничног услова

.. math::
    c (n\cdot\nabla U) + \frac{\partial U}{\partial t} = 0, \qquad x\in\Gamma_2,

таласи који ударају у границу :math:`\Gamma_2` под правим углом биће савршено апсорбовани. Са друге стране, они делови таласног поља који не падају под правим углом не задовољавају овај услов, па ће долазити до парцијалних рефлексија. У основи, директни делови таласа ће проћи кроз границу као да она не постоји, док ће остали бити рефлектовани назад у домен. 

Уколико смо спремни да прихватимо овако предложену апроксимацију, онда за :math:`u` важи следеће: 

.. math::
    :label: eq:sistem

    -\omega^2 u - c^2\Delta u = 0, \qquad x \in \Omega, \\
    c (n\cdot\nabla u) + i\,\omega\, u=0, \qquad x \in \Gamma_2, \\
    u=1,  \qquad x \in \Gamma_1.

препознајемо Хелмхолцову једначину са Дирихлеовим условом на :math:`\Gamma_1` и мешаним граничним условом на :math:`\Gamma_2`. Због услова на :math:`\Gamma_2` не можемо да третирамо реалане и имагинарне делове :math:`u` посебно. Оно што можемо да урадимо је да формирамо систем од две парцијалне диференцијалне једначине у којима фигуришу реални и имагинарни део :math:`u`, са граничним условима на :math:`\Gamma_2` које везују ове две компоненте. Ако означимо да је :math:`v=\textrm{Re}\;u,\; w=\textrm{Im}\;u`, систем :math:numref:`eq:sistem` гласи:  

.. math::
    :label: eq:sistem1

    -\omega^2 v - c^2 \Delta v=0 \quad \\
    -\omega^2 w - c^2 \Delta w=0 \quad \\
    x \in \Omega,
        \\
    c (n\cdot\nabla v) - \omega \, w=0 \quad \\
    c (n\cdot\nabla w) + \omega \, v=0 \quad \\
    x \in \Gamma_2, 
    \\
    v=1 \quad \\
    w=0 \quad \\
    x \in \Gamma_1.

Дакле, прве две једначине важе у целом домену :math:`\Omega`, друге две на граници :math:`\Gamma_2`, а последље две на :math:`\Gamma_1`. Овде први пут имамо систем диференцијалних једначина, али ни то не би требало да буде проблем за ФПНМ приступ, ако подразумевамо да је систем затворен, тј. једнозначан. 


Имплементација
-----------------

На основу система једначина :math:numref:`eq:sistem1` треба да формирамо композитну функцију губитка, да формирамо ФПНМ мрежу и да је истренирамо на довољном броју колокационих тачака. Ево кључних делова имплементације остварене помоћу оквира SCIANN:

.. code-block:: python
    :caption: Решење проблема простирања таласа у 2Д домену са сочивом
    :linenos:

    import numpy as np
    import matplotlib.pyplot as plt 
    import sciann as sn
    from numpy import pi
    from sciann.utils.math import diff, sign, sin, sqrt

    # Brzina talasa
    c = 1
    # Frekvencija
    omega = 2*pi*4

    x = sn.Variable('x')
    y = sn.Variable('y')
    v, w = sn.Functional (["v", "w"], [x, y], 3*[200] , 'sin')

    # Diferencijalne jednacine za v i w
    L1 = -omega**2 * v - c**2 * diff(v, x, order=2) - c**2 * diff(v, y, order=2) 
    L2 = -omega**2 * w - c**2 * diff(w, x, order=2) - c**2 * diff(w, y, order=2)

    TOL = 0.015

    # Dirihleov uslov na G1 (y=0 i 0.4<x<0.6)
    a,b,c,d =  0.39762422, -1.57715550, -0.03696364,  1.60337246
    C1 = (1 - sign(y - (a + b*x + c*sqrt(x) + d*x**2 + TOL))) * (1 + sign(x-0.4)) * (1 - sign(x-0.6)) * (1-v) 
    C2 = (1 - sign(y - (a + b*x + c*sqrt(x) + d*x**2 + TOL))) * (1 + sign(x-0.4)) * (1 - sign(x-0.6)) * (w-0)

    # Gornja granica G2 (gde je y=1)
    C3 =  (1+sign(y - (1-TOL))) * ( c*diff(v,y) - omega*w )
    C4 =  (1+sign(y - (1-TOL))) * ( c*diff(w,y) + omega*v )

    # Desna granica G2 (gde je x=1)
    C5 =  (1+sign(x - (1-TOL))) * ( c*diff(v,x) - omega*w )
    C6 =  (1+sign(x - (1-TOL))) * ( c*diff(w,x) + omega*v )

    # Leva granica G2 (gde je x=0)
    C7 =  (1-sign(x - (0+TOL))) * ( -c*diff(v,x) - omega*w )
    C8 =  (1-sign(x - (0+TOL))) * ( -c*diff(w,x) + omega*v )

    # Donja granica G2 (gde je y=0) i (x<0.4 or x>0.6)
    C9 =   (1-sign(y - (0+TOL))) * ( (1 - sign(x-0.4)) + (1 + sign(x-0.6)) ) * ( -c*diff(v,y) - omega*w )
    C10 =  (1-sign(y - (0+TOL))) * ( (1 - sign(x-0.4)) + (1 + sign(x-0.6)) ) * ( -c*diff(w,y) + omega*v )

    x_data, y_data = [], []

    kolokacione_tacke = np.genfromtxt('kolokacione_tacke.txt', delimiter=" ")

    for e in kolokacione_tacke:
        ind, x1, y1 = e
        x_data.append(x1)
        y_data.append(y1)

    x_data, y_data = np.array(x_data), np.array(y_data)

    # Model i obucavanje
    m = sn.SciModel([x, y], [L1,L2,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10], 'mse', 'Adam')
    h = m.train([x_data, y_data], 12*['zero'], learning_rate=0.001, batch_size=1024, epochs=8000, adaptive_weights={'method':'NTK', 'freq':200})

    # Test
    x_test, y_test = np.meshgrid(
        np.linspace(0, 1, 200), 
        np.linspace(0, 1, 200)
    )
    v_pred = v.eval(m, [x_test, y_test])
    w_pred = w.eval(m, [x_test, y_test])

Након уобичајених импорта пакета, формирамо ФПНМ мреже за реални део :math:`v` и имагинарни део :math:`w` непознате функције :math:`u`. И овде ћемо ићи са аактивационом функцијом :math:`\sin(x)`. Интересантан део кода је дефинисање граничног услова на :math:`\Gamma_1` према последње две једначине у систему :math:numref:`eq:sistem1`:

.. code-block:: python

    a,b,c =  0.39762422, -1.57715550, 1.60337246
    C1 = (1 - sign(y - (a + b*x + c*x**2 + TOL))) * (1 + sign(x-0.4)) * (1 - sign(x-0.6)) * (1-v)
    C2 = (1 - sign(y - (a + b*x + c*x**2 + TOL))) * (1 + sign(x-0.4)) * (1 - sign(x-0.6)) * (w-0)

Једначина :math:`y = a + b \cdot x + c \cdot x^2` представља једначину спољне линије сочива :math:`\Gamma_1`, у којој су коефицијенти :math:`a,b,c` добијени фитовањем. Дакле, прва заграда у граничним условима значи да узимамо колокационе тачке које припадају танком појасу изнад линије :math:`\Gamma_1`, док друга и трећа заграда имају ненулту вредност само ако је :math:`0,4 < x < 0,6`. 

Гранични услови ``C3, C4, C5, C6, C7, C8`` се односе на мешану формулацију према друге две једначине у систему :math:numref:`eq:sistem1` и важе на :math:`\Gamma_2`. На пример:

.. code-block:: python

    C5 =  (1+sign(x - (1-TOL))) * ( c*diff(v,x) - omega*w )
    C6 =  (1+sign(x - (1-TOL))) * ( c*diff(w,x) + omega*v )

се односи на десну границу где је ``x=1`` и узима колокационе тачке које се налазе у танком појасу ширине ``TOL`` са леве стране те границе. 

Компоненте функције губитка ``C9`` и ``C10`` односе се такође на границу :math:`\Gamma_2`, али на линији где је :math:`y=0`` и :math:`x < 0,4` или :math:`x > 0,6`:

.. code-block:: python

    C9 =   (1-sign(y - (0+TOL))) * ( (1 - sign(x-0.4)) + (1 + sign(x-0.6)) ) * ( -c*diff(v,y) - omega*w )
    C10 =  (1-sign(y - (0+TOL))) * ( (1 - sign(x-0.4)) + (1 + sign(x-0.6)) ) * ( -c*diff(w,y) + omega*v )

Овим смо комплетирали свих 12 компоненти функције губитка. Пошто их има толико, није једноставно извршити њихово пондерисање, односно доделу тежина свакој компоненти. У оваквим ситуацијама помажу методе за адаптивно одређивање тежина компоненти током обуке. У нашем решењу:

.. code-block:: python

    h = m.train([x_data, y_data], 12*['zero'], learning_rate=0.001, batch_size=1024, epochs=8000, adaptive_weights={'method':'NTK', 'freq':200})

употребили смо иновативну методу *Neural Tangent Kernel* (NTK) према :cite:t:`wang2022and`. Објашњење методе излази из оквира овог практикума, па је нећемо детаљно разрађивати. Такође, ваља напоменути да смо колокационе тачке учитали из посебног фајла ``kolokacione_tacke.txt``, који је добијен тако што смо исписали чворове коначних елемената који се добијају из генератора мреже `пакета Deal.II <https://www.dealii.org>`_. 


Резултати
-------------

Као што је на почетку одељка већ речено, пример је преузет из документације за пакет који се бави анализом методом коначних елемената `Deal.II <https://www.dealii.org/current/doxygen/deal.II/step_29.html>`_, тако да можемо да упоредимо решење за :math:`v=\textrm{Re}\;u` које смо добили помоћу ФПНМ (:numref:`socivo-res-pinn`) и решење које се добија класичном методом коначних елемената (:numref:`socivo-res-fem`). Решење добијено МКЕ методом можемо сматрати референтним, јер је коришћена веома густа мрежа и показана је конвергенција. 

.. _socivo-res-pinn:

.. figure:: socivo-v.png
    :width: 80%

    Решење за :math:`v=\textrm{Re}\;u` добијено помоћу ФПНМ


.. _socivo-res-fem:

.. figure:: rezultati-socivo-fem1.png
    :width: 80%

    Решење за :math:`v=\textrm{Re} \; u` добијено методом коначних елемената

Квалитативно гледано, ФПНМ решење има исте карактеристике као МКЕ решење. Међутим, око сочива и прима границама :math:`\Gamma_2` очигледан је пад квалитета решења. Узрок можемо тражити на неколико места:

- Прво, код МКЕ је извор на линији сочива :math:`\Gamma_1` могуће прецизније специфицирати по самој линији, а не у појединачним тачкама као код ФПНМ. 
- Могуће је да 50.000 колокационих тачака није довољно за обучавање.
- Примећено је да обучавање оптимизационим алгоритам ``Adam`` не може да спусти вредност губитка испод неке границе. Овде вероватно треба експериментисати са варијабилном стопом учења, или додати неки други оптимизатор као у примеру :ref:`poplavni`.

Даље експериментисање на овом примеру остављамо читаоцу. 